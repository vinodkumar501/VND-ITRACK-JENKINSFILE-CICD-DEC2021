Jenkinsfile (Scripted Pipeline)

start with node and not have stages like declarative
having only stage

//https://www.jenkins.io/doc/book/pipeline/jenkinsfile/

node {
    checkout scm 
    /* .. snip .. */
}


--------------------- scripted pipeline1 ----------------------

node{
  stage ('checkout')
  checkout scm
 }
  
//The checkout step will checkout code from source control; 
//scm is a special variable which instructs the checkout step to clone the specific revision which triggered this Pipeline run


--------------------- scripted pipeline2 ----------------------

node {
    def nodeHome = tool name: 'node'//, type: 'jenkins.plugins.nodejs.tools.NodeJSInstallation'
    env.PATH = "${nodeHome}/bin:${env.PATH}"

    stage('check tools') {
        sh "node -v"
        sh "npm -v"
    }

    stage('checkout') {
        checkout scm
    }

    stage('npm install') {
        nodejs('node'){
        //sh "npm init"
        sh "npm install yarn"
        }
      }

    //stage('unit tests') {
        //sh "npm test -- --watch=false"
    //}

    //stage('protractor tests') {
        //sh "npm run e2e"
    //}
}  

-------------------------->CICD <--------------------------

build pipeline plugin ---> useful for few jobs (each task we need to create job )and integrate all
but it useful for few jobs only. so jenkinsfile use

Jenkinsfile: ( prefer for more no of jobs are there )
1.Declarative pipeline:
if I create file using groovy script that file is called  jenkinsfile that file will be there in central repo, that file run in jenkins ----> declarative jenkinsfile

2.Scripted pipeline: groovy:
just write small groovy script inside jenkins directly.

pipeline: is a job inside each and everything like subjob
https://www.jenkins.io/doc/book/pipeline/syntax/

STEP:
most fundamental part of a Pipeline is the "step". Basically, steps tell Jenkins what to do and serve as the basic building block for both Declarative 
and Scripted Pipeline syntax.

========================================== Declarative Pipeline ========================================== 
Declarative Pipeline is a relatively recent addition to Jenkins Pipeline [1] which presents a more simplified and opinionated syntax on top of the Pipeline sub-systems.

All valid Declarative Pipelines must be enclosed within a pipeline block, for example:

pipeline {
    /* insert Declarative Pipeline here */
}

The top-level of the Pipeline must be a block, specifically: pipeline { }.

Limitations
There is currently an open issue which limits the maximum size of the code within the pipeline{} block. This limitation does not apply to Scripted pipelines

agent:
The agent section specifies where the entire Pipeline, or a specific stage, will execute in the Jenkins environment depending on where the agent section is placed.
The section must be defined at the top-level inside the pipeline block, but stage-level usage is optional.

Parameters
In order to support the wide variety of use-cases Pipeline authors may have, the agent section supports a few different types of parameters. These parameters can be applied at the top-level of the pipeline block, or within each stage directive.

-> any
Execute the Pipeline, or stage, on any available agent. For example: agent any

pipeline{
agent any 
}

-> label
A string. The label or label condition on which to run the Pipeline or individual stage.

This option is valid for node, docker, and dockerfile, and is required for node.

PIPELINE:
We can execute multiple jobs in sequential manner ---> all include in Jenkinsfile

If your jobs are increasing it make much complex to add in build pipeline plugin so use Jenkinsfile ( in groovy script)
every job consider as stage --- in jenkinsfile
Just need to define all in script will run one after another ----> this approach is involved if more no of activitise or jobs involved.

Single pipeline ---> all we included all job 
pipline as job ---> inside are subjobs


DECLARATIVE:
If create a script( jenkinsfile) then that file in central repo along with project that file and run it in jenkins -----Declarative pipeline

===================================== Jenkinsfile1==============================================

node {
   def mvnHome = tool name: 'mvn-3.8.4'              //def mvn tool "mvn-3.8.4' name mentioned in global tool configuration
   stage('checkout git scm') {
      git credentialsId: 'git-cred', url: 'https://github.com/vinodkumar501/vnd-itrack-jenkinsfile-CICD-DEC2021.git'
	   //http://3.94.101.38:8080/job/declarative%20pipeline/pipeline-syntax/ 
	   //use this for above git row creation "generate //pipleinscript
    }
   stage('package'){
      sh "${mvnHome}/bin/mvn -v"
      sh "${mvnHome}/bin/mvn clean package"          //you must add "" before interpolation ${mvnHome}
    }
   stage('SonarQube analysis') {
      //def scannerHome = tool 'SonarScanner 4.0';
      withSonarQubeEnv('sonarqube-9.2') { // If you have configured more  one global server connection, you specify its name
      //sh "${scannerHome}/bin/sonar-scanner"
	  sh "${mvnHome}/bin/mvn sonar:sonar"
    }
  }
}
==============================================================================================

=========================================  Jenkinsfile3 ====================================================

def CONTAINER_NAME="jenkins-pipeline"
def CONTAINER_TAG="latest"
def DOCKER_HUB_USER="hakdogan"
def HTTP_PORT="8090"

node {

    stage('Initialize'){
        def dockerHome = tool 'myDocker'
        def mavenHome  = tool 'myMaven'
        env.PATH = "${dockerHome}/bin:${mavenHome}/bin:${env.PATH}"
    }

    stage('Checkout') {
        checkout scm
    }

    stage('Build'){
        sh "mvn clean install"
    }

    stage('Sonar'){
        try {
            sh "mvn sonar:sonar"
        } catch(error){
            echo "The sonar server could not be reached ${error}"
        }
     }

    stage("Image Prune"){
        imagePrune(CONTAINER_NAME)
    }

    stage('Image Build'){
        imageBuild(CONTAINER_NAME, CONTAINER_TAG)
    }

    stage('Push to Docker Registry'){
        withCredentials([usernamePassword(credentialsId: 'dockerHubAccount', usernameVariable: 'USERNAME', passwordVariable: 'PASSWORD')]) {
            pushToImage(CONTAINER_NAME, CONTAINER_TAG, USERNAME, PASSWORD)
        }
    }

    stage('Run App'){
        runApp(CONTAINER_NAME, CONTAINER_TAG, DOCKER_HUB_USER, HTTP_PORT)
    }

}

def imagePrune(containerName){
    try {
        sh "docker image prune -f"
        sh "docker stop $containerName"
    } catch(error){}
}

def imageBuild(containerName, tag){
    sh "docker build -t $containerName:$tag  -t $containerName --pull --no-cache ."
    echo "Image build complete"
}

def pushToImage(containerName, tag, dockerUser, dockerPassword){
    sh "docker login -u $dockerUser -p $dockerPassword"
    sh "docker tag $containerName:$tag $dockerUser/$containerName:$tag"
    sh "docker push $dockerUser/$containerName:$tag"
    echo "Image push complete"
}

def runApp(containerName, tag, dockerHubUser, httpPort){
    sh "docker pull $dockerHubUser/$containerName"
    sh "docker run -d --rm -p $httpPort:$httpPort --name $containerName $dockerHubUser/$containerName:$tag"
    echo "Application started on port: ${httpPort} (http)"
}



===============================Jenkinsfile -----Mail notification ===========================================
node{
   stage('SCM Checkout'){
     git 'https://github.com/javahometech/my-app'
   }
   stage('Compile-Package'){
      // Get maven home path
      def mvnHome =  tool name: 'maven-3', type: 'maven'   
      sh "${mvnHome}/bin/mvn package"
   }
   stage('Email Notification'){
      mail bcc: '', body: '''Hi Welcome to jenkins email alerts
      Thanks
      Hari''', cc: '', from: '', replyTo: '', subject: 'Jenkins Job', to: 'hari.kammana@gmail.com'
   }
   stage('Slack Notification'){
       slackSend baseUrl: 'https://hooks.slack.com/services/',
       channel: '#jenkins-pipeline-demo',
       color: 'good', 
       message: 'Welcome to Jenkins, Slack!', 
       teamDomain: 'javahomecloud',
       tokenCredentialId: 'slack-demo'
   }
}
































